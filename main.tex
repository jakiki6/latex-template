\documentclass[8pt, letterpaper]{article}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{gensymb}
\usepackage{blindtext}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{url}
\usepackage{seqsplit}
\usepackage{hyperref}

\graphicspath{{images/}}
\setlength{\parindent}{0cm}
\bibliographystyle{gerplain}
\geometry{letterpaper, margin=1in}
\pagestyle{fancy}

\lhead{Jakob Kirsch und Felix Warschburger}
\rhead{\includegraphics[width=3cm]{logo}}

\title{}
\author{Jakob Kirsch und Felix Warschburger}
\date{\parbox{\linewidth}{\centering%
  \today\endgraf\bigskip
  Fach: InVer\endgraf\medskip
  Betreuer: Herr Maier\endgraf\medskip
}}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Formuliertes Ziel}
Unser ursprüngliches Ziel war es, eine App zu entwickeln, bei der man durch Berührung Partikel beeinflussen kann, wie als wären diese durch Gravitation angezogen. Die Idee kam daher, dass Felix eine Planetensimulation programmiert hat und diese ganz interessant aussah. Wir haben während der Entwicklung unser Ziel erweitert, was wir in einem zusätzlichen Abschnitt erläutern werden.

\section{Benutzte Tools}
\begin{itemize}
    \item Android Studio
    \item Android NDK (C++)
\end{itemize}

\section{Timeline der Entwicklung}
\begin{itemize}
    \item Android App Projekt erstellt
    \item Schwarzes Canvas hinzugefügt
    \item Code hinzugefügt, mit dem man einzelne Partikel in weiß rendern kann
    \item Proof-of-concept Code in Java geschrieben, welcher alle nötigen Berechnungen macht, damit sich die Partikel bewegen
    \begin{itemize} \item Problem: Java ist super langsam, der Code laggt mit mehr als 1000 Partikeln. Wir wollen aber eher 100.000 bis 1.000.000 Partikel \end{itemize}
    \item Logische Schlussfolgerung: performance-kritischen Teil in C++ neuschreiben.
    \begin{itemize} \item Hier fangen die Probleme an \end{itemize}
    \item Problem: wenn man einen ByteBuffer an Floats übergibt, kommen auf der C++-Seite sehr komische Zahlen an. Lösung: ein Float-Array übergeben und dann die Werte so auslesen
    \item Problem: das gleiche passiert mit ArrayList<Float>, womit wir die Berührungspunkte übergeben Lösung: auch Float-Array übergeben
    \item Problem: Rendercode ist viel zu langsam (hängt bei mehr als 10.000 Partikel) Lösung: Partikel werden gerendert, indem man den Pixel setzt statt einen Kreis mit Durchmesser 1 zu rendern
    \item Problem: es ist immernoch zu langsam Lösung: auch wieder in C++ neuschreiben.
    \item Problem: Bug in Android: wenn man \texttt{env->NewDirectByteBuffer()} benutzt, um einen ByteBuffer in C++ zu erzeugen, und man diesen dann zurückgibt, erscheint es auf der Java-Seite so, als ob dieser ByteBuffer eine Kapazität von 0 hat. Lösung: Wir übergeben einen bereits allokierten ByteBuffer als Argument.
    \item Einstellungen hinzufügen (z.B. Partikelmenge)
    \item Zwei neue Activities hinzugefügt: Grid und Ant

\end{itemize}

\section{Aktuelle Features}
Beim öffnen der App sieht man die folgenden 4 Optionen.

\subsection{Settings}
Hier kann Einstellungen ändern.

\subsection{Particles}
Hier wird der Bildschirm mit einer einstellbaren Menge an Partikeln gefüllt. Diese kann man dann beeinflussen, indem man den Bildschirm berührt, wodurch diese gemäß der Gesetze der Gravitation an die Berührungspunkte angezogen werden.
Einstellungen: Partikelmenge (hängt von der Leistung des Geräts ab).

\subsection{Grid}
Hier kann man ein Schachbrettmuster generieren, wobei die einzelnen Felder eine konfigurierbare Größe haben. Wenn man nun mit einem zweiten Gerät die Kamera auf den Bildschirm richtet, bildet sich ein sogenanntes Moiré-Muster. Alternativ kann man auch einen Screenshot machen oder in die Übersicht aller geöffneten Apps gehen, da in beiden Fällen das Bild gedownscaled wird und sich Muster bilden.
Einstellungen: Größe der Felder

\subsection{Ant}
Hier kann man den Zellulären Automat namens "Ameise" (engl.: Langton's ant) beobachten. Er funktioniert, indem man eine konfigurierbare Menge an "Ameisen" zufällig auf eine schwarz-weiße Oberfläche setzt. In jedem Schritt guckt jede Ameise auf die Farbe in dem aktuellen Feld unter sich und dreht sich bei Weiß um 90 Grad nach rechts und bei Schwarz um 90 Grad nach links. Danach wechselt sie die Farbe des Feldes von Schwarz zu Weiß oder umgekehrt. Danach geht sie einen Schritt in Blickrichtung. Diese einfachen Regeln erzeugen ein interessantes Muster. Nach einer gewissen Zeit ist der Bildschirm komplett befüllt und es sieht so aus, als ob Ameisen auf dem Bildschirm umherlaufen.
Einstellungen: Menge der Ameisen und Schritte pro Frame.

\section{Codestruktur}
Es gibt 6 Klassen:
\begin{itemize}
    \item AntActivity: Activity für Langton's ant
    \item GridActivity: Activity für den Moiré-Effekt
    \item MainActivity: Activity, die beim Öffnen angezeigt wird
    \item Native: JNI bindings für den C++ Code
    \item ParticleActivity: Activity für die Partikelsimulation
    \item SettingsActivity: Activity für die Einstellungen
\end{itemize}

und eine C++ Datei namens "native.cpp", welche den C++ Code enthält.

\section{Reflektion}
Das haben wir gelernt:
\begin{itemize}
    \item Java ist sehr sehr sehr langsam
    \item C++ und Java zu verbinden ist sehr aufwendig aufgrund von Bugs in JNI auf Android
\end{itemize}

Leider konnten wir keine Bilder der App hinzufügen, da diese mit pixelpräzision rendert und alle Bilder die auch nur irgendwie komprimiert werden sehr schlimm aussehen.
Das Design der App sollte es erlauben, noch mehr Features zu verbauen.

Der Code der App ist unter der GPLv3-Lizenz hier zu sehen: https://github.com/jakiki6/particles
Der Code dieses Dokuments ist hier zu sehen: https://github.com/jakiki6/latex-template/tree/infver/particles

\end{document}
